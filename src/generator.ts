// ============================================================================
// FRONTBLOK-CRUD - ENTITIES.TS GENERATOR
// ============================================================================
// Generates TypeScript interfaces and entity registry from a JSON schema.
//
// WHAT IT GENERATES:
// 1. TypeScript interfaces for each entity
// 2. CreateInput and UpdateInput types
// 3. Entity registry (const entities = {...} as const)
//
// USAGE (by MCP):
// ```typescript
// import { generateEntitiesTs } from '@rationalbloks/frontblok-crud';
// 
// const schema = { tasks: { title: { type: 'string', required: true } } };
// const code = generateEntitiesTs(schema);
// fs.writeFileSync('src/entities.ts', code);
// ```
// ============================================================================

import type { Schema, EntityConfig, FieldConfig, FieldType } from './types.js';
import {
  toPascalCase,
  toSingular,
  toPlural,
  schemaTypeToTs,
} from './utils.js';

// Generate complete entities.ts content from a schema.
// This is THE ONLY generation function needed.
export function generateEntitiesTs(schema: Schema): string {
  const lines: string[] = [
    '// ============================================================================',
    '// ENTITY DEFINITIONS',
    '// ============================================================================',
    '// Generated by RationalBloks MCP',
    '// DO NOT EDIT MANUALLY - Regenerate from schema',
    '//',
    `// Generated: ${new Date().toISOString()}`,
    '// ============================================================================',
    '',
    "import type { BaseEntity, CreateInput, UpdateInput, EntityRegistry } from '@rationalbloks/frontblok-crud';",
    '',
  ];

  // Generate interfaces for each entity
  for (const [tableName, fields] of Object.entries(schema)) {
    lines.push(...generateEntityInterface(tableName, fields));
    lines.push('');
  }

  // Generate entity registry
  lines.push(...generateEntityRegistry(schema));

  return lines.join('\n');
}

// Generate TypeScript interface for a single entity.
function generateEntityInterface(
  tableName: string,
  fields: EntityConfig
): string[] {
  const typeName = toPascalCase(toSingular(tableName));
  const lines: string[] = [];

  // Main interface
  lines.push('// ----------------------------------------------------------------------------');
  lines.push(`// ${typeName}`);
  lines.push('// ----------------------------------------------------------------------------');
  lines.push('');
  lines.push(`export interface ${typeName} extends BaseEntity {`);

  for (const [fieldName, fieldConfig] of Object.entries(fields)) {
    // Skip metadata fields
    if (fieldName.startsWith('_')) continue;

    const tsType = getTypeScriptType(fieldConfig);
    const optional = fieldConfig.required ? '' : '?';
    const comment = fieldConfig.description ? ` // ${fieldConfig.description}` : '';

    lines.push(`  ${fieldName}${optional}: ${tsType};${comment}`);
  }

  lines.push('}');
  lines.push('');

  // Create input type
  lines.push(`export type Create${typeName}Input = CreateInput<${typeName}>;`);
  lines.push('');

  // Update input type
  lines.push(`export type Update${typeName}Input = UpdateInput<${typeName}>;`);

  return lines;
}

// Get TypeScript type string for a field config.
// Handles enums and basic types.
function getTypeScriptType(fieldConfig: FieldConfig): string {
  // Handle enum types
  if (fieldConfig.enum && fieldConfig.enum.length > 0) {
    return fieldConfig.enum.map(v => `'${v}'`).join(' | ');
  }

  // Handle basic types
  return schemaTypeToTs(fieldConfig.type);
}

// Generate entity registry for runtime use.
function generateEntityRegistry(schema: Schema): string[] {
  const lines: string[] = [
    '// ============================================================================',
    '// ENTITY REGISTRY',
    '// ============================================================================',
    '// Runtime metadata for dynamic entity operations.',
    '// Used by hooks and forms to work with any entity type.',
    '',
    'export const entities = {',
  ];

  const entries = Object.entries(schema);
  for (let i = 0; i < entries.length; i++) {
    const [tableName, fields] = entries[i];
    const singular = toSingular(tableName);
    const plural = toPlural(tableName);
    const isLast = i === entries.length - 1;

    lines.push(`  ${tableName}: {`);
    lines.push(`    singular: '${singular}',`);
    lines.push(`    plural: '${plural}',`);
    lines.push(`    fields: ${formatFieldsAsTs(fields)},`);
    lines.push(`  }${isLast ? '' : ','}`);
  }

  lines.push('} as const satisfies EntityRegistry;');
  lines.push('');

  // Export type for the registry
  lines.push('export type Entities = typeof entities;');
  lines.push('export type EntityName = keyof Entities;');

  return lines;
}

// Format fields object as TypeScript object literal.
// Compact single-line format for readability.
function formatFieldsAsTs(fields: EntityConfig): string {
  const fieldEntries: string[] = [];

  for (const [fieldName, fieldConfig] of Object.entries(fields)) {
    // Skip metadata fields
    if (fieldName.startsWith('_')) continue;

    const props: string[] = [];
    props.push(`type: '${fieldConfig.type}'`);

    if (fieldConfig.required) {
      props.push('required: true');
    }
    if (fieldConfig.unique) {
      props.push('unique: true');
    }
    if (fieldConfig.max_length) {
      props.push(`max_length: ${fieldConfig.max_length}`);
    }
    if (fieldConfig.enum) {
      props.push(`enum: [${fieldConfig.enum.map(v => `'${v}'`).join(', ')}]`);
    }
    if (fieldConfig.foreign_key) {
      props.push(`foreign_key: '${fieldConfig.foreign_key}'`);
    }

    fieldEntries.push(`${fieldName}: { ${props.join(', ')} }`);
  }

  // Use multi-line format if there are many fields
  if (fieldEntries.length > 3) {
    return '{\n      ' + fieldEntries.join(',\n      ') + '\n    }';
  }

  return '{ ' + fieldEntries.join(', ') + ' }';
}

// ============================================================================
// VALIDATION
// ============================================================================

// Validate a schema before generation.
// Returns array of error messages (empty if valid).
export function validateSchema(schema: Schema): string[] {
  const errors: string[] = [];

  if (!schema || typeof schema !== 'object') {
    errors.push('Schema must be an object');
    return errors;
  }

  const validTypes: FieldType[] = [
    'string', 'text', 'integer', 'decimal', 
    'boolean', 'datetime', 'date', 'uuid', 'json'
  ];

  for (const [tableName, fields] of Object.entries(schema)) {
    if (!fields || typeof fields !== 'object') {
      errors.push(`Table '${tableName}' must have a fields object`);
      continue;
    }

    for (const [fieldName, fieldConfig] of Object.entries(fields)) {
      // Skip metadata
      if (fieldName === '_id') continue;

      if (!fieldConfig || typeof fieldConfig !== 'object') {
        errors.push(`${tableName}.${fieldName}: Field config must be an object`);
        continue;
      }

      if (!fieldConfig.type) {
        errors.push(`${tableName}.${fieldName}: Missing 'type' property`);
        continue;
      }

      if (!validTypes.includes(fieldConfig.type)) {
        errors.push(`${tableName}.${fieldName}: Invalid type '${fieldConfig.type}'`);
      }

      // Validate string requires max_length
      if (fieldConfig.type === 'string' && !fieldConfig.max_length) {
        errors.push(`${tableName}.${fieldName}: string type requires max_length`);
      }

      // Validate decimal requires precision and scale
      if (fieldConfig.type === 'decimal') {
        if (!fieldConfig.precision) {
          errors.push(`${tableName}.${fieldName}: decimal type requires precision`);
        }
        if (fieldConfig.scale === undefined) {
          errors.push(`${tableName}.${fieldName}: decimal type requires scale`);
        }
      }
    }
  }

  return errors;
}
